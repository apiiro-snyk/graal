# Native cgroup support for SVM

This contains `libsvm_container`, the native cgroup support for SVM (libsvm_container).
The C code is ported from the OpenJDK and currently based on:
https://github.com/openjdk/jdk/tree/9049402a1b9394095b04287eef1f2d46c4da60e9/src/hotspot

## Building

The code is built via `mx build`, so no special actions are required. There is
[`configure.py`](./configure.py), that generates a `build.ninja` that can help with local debugging,
but it is not used by `mx build` and there is no guarantee that it works correctly. Use at your own 
risk. The default `mx build` command only uses settings from `suite.py`, so values in
`build.ninja` or those generated by `configure.py` might be outdated.

## Dependencies

For building `libsvm_container`, a C++14 compiler is required. Some parts of `libsvm_container` depend on `libm`.
At image build time, `native-image` will automatically link statically against `libsvm_container` and `libm`.
No further dependencies are needed at image build or image run time.
Specifically,  `libsvm_container` does _not_ depend on any code from the C++ standard library.

## Code Layout

The file structure is inherited from the OpenJDK. The Files in [`src/hotspot`](./src/hotspot) are
mostly unmodified except for sections guarded with `#ifdef NATIVE_IMAGE`. The Files in
[`src/svm`](./src/svm) are replacements for files that exist in the OpenJDK, but are completely
custom. They only provide the minimal required functionality and are specific to SVM.

## Updating

While the code in here is completely independent and does not need to be in sync with the OpenJDK,
it should be updated regularly to profit from upstream fixes and improvements. To do so, replace
the files in [`src/hotspot`](./src/hotspot) with those from the OpenJDK. Then reapply all the
changes (`#ifdef` guards) using the diff tool of your choice. Finally, adopt the files in
[`src/svm`](./src/svm) to provide new functionality, if needed. Don't forget to update the import
revision mention in this file.

## Local Testing

There are various ways for running applications like native images in cgroups.
Also note that many containerization tools such as Docker use cgroups for resource constraints.

### Using CGroup commands

The most basic way of running a program in a cgroup is to create them manually. For example:

```bash
# create cgroup
cgcreate -a <user> -t <user> -g memory,cpu:testgroup
ls -l /sys/fs/cgroup/cpu/testgroup
ls -l /sys/fs/cgroup/memory/testgroup

# set limits
echo 10000000 > /sys/fs/cgroup/memory/testgroup/memory.limit_in_bytes
echo 12000000 > /sys/fs/cgroup/memory/testgroup/memory.soft_limit_in_bytes
echo 100 > /sys/fs/cgroup/cpu/testgroup/cpu.shares

# run image in cgroup
cgexec -g memory,cpu:testgroup ./test

# delete cgroup
cgdelete -g memory,cpu:testgroup
```

### Using systemd

Another possibility is to run a program in a transient systemd scope with resource constraints:

```bash
systemd-run --scope -p MemoryMax=2G --user ./test
```
